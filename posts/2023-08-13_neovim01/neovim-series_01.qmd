---
title: "Reflections from a Month of NeoVim"
subtitle: "Neovim for Science: Post 01"
date: "2023-08-31"
description: |
    The first in an unorganized series of thoughts about using Neovim for scientific computing.
categories:
    - neovim
    - r
    - julia
    - quarto
    - science
    - repl
    - ide
image-alt: 'Photo by <a href="https://unsplash.com/@timberfoster?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Tim Foster</a> on <a href="https://unsplash.com/photos/qefCF3r4Eoc?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>'
---

Recently, I made the decision to go all-in with [NeoVim](https://neovim.io).
If you're not family with Vi(m) or NeoVim, it's a fairly bare-bones, but incredibly, powerful text editor.
If you've ever opened a file in Unix terminal, whether that be on your Mac or a Linux machine, or even a server, there's a good chance you've used Vi(m).
While this switch is certainly not unheard of, particularly in the wider programming world, I can't say I know many scientists (outside of CS, that is) who use it.
In a world where everyone is using RStudio for R (and increasingly Python) programming, and VSCode dominates everything else, why would I possibly move to a text editor that doesn't have all of the creature comforts that are baked into modern IDEs?

Over the next couple of posts I hope to answer that question, and maybe even convince you to give it a try.
The first post in this mini-series will outline my motivations for switching and the bigger picture, and the subsequent posts will focus on the technical aspects and how I've made it work for me and my needs in scientific computing.
Long story short, I've found it to be a really enjoyable experience, and it has helped me become a better programmer through gaining a deeper understanding of the tools I use every day, which has transferred back to a better understanding of the languages I use for my work.

## Where I'm coming from

Before we talk about motivations, I think it's important to outline the type of work that I do, and what tools I've used in the past, as no editor is a one-size-fits-all solution.

In my day-to-day work, I use the R and Julia programming languages to clean lots of population-level infection data, build statistical (think GLM) and dynamical (think SIR) models, create lots of figures, and write papers and summary reports using [Quarto](https://quarto.org) notebooks.
All of this is fairly typical of a scientist in the modern era, where most of our work is now performed on computers.

As a result of being researcher who's work is entirely computational, it's important that the text editor I use fits my needs.
But these needs are not the same as a software developer's, who is the primary target for most IDEs, so seemingly inconsequential grievances can be deal-breakers for researchers.


## What I need & want from an editor

Given the work outlined above, there are a number of non-negotaible features that I **need** from an editor:

<div class="box" style="padding-bottom:0">
1. **Interactive editing** of R and Julia code, including the ability to send **code chunks** to a REPL/console.
2. **Syntax and error highlighting** for R, Julia, and Markdown (and ideally LaTeX).
3. **Autocompletion** of R and Julia code, including in a Quarto notebook.
4. **Easy plot creation and viewing**.
</div>

Most of these should hopefully be self-explanatory given the workflow I outlined above, and it was not immediately obvious that all were possible within NeoVim (within a reasonable enough time-frame before I gave up and went back to what I was used to).

There are also a number of features that I **want** from an editor, but could live without:

<div class="box" style="padding-bottom:0">
1. **First-class Git integration**.
2. **Spell checking**.
3. **Code formatting**.
4. **Extensibility** through plugins as I decide to learn new languages or workflows.
5. **Quick start up times**.
6. **Simple configuration** of keymaps, snippets, etc.
7. **Easy navigation** of files and projects.
8. **Good file manipulation** (e.g. moving, copying, deleting, etc.).
</div>

## What's wrong with RStudio & VSCode?

Like most people, I started learning R using RStudio, and I still think it's a great tool.
It is incredibly easy to set up, and it does all of my four essentials for R out of the box.
It can also do most of my wants with somewhat minimal effort.
So why switch?

As mentioned, I've been using Julia more and more as I've transitioned from traditional epidemiological analysis with statistical models to building dynamical models of infectious disease, which are much more computationally intensive (particularly for ensemble stochastic simulations) and benefit from a faster language.
Plus, it's fun learning a new language and has made me a better programmer in general, which benefits my R work as well.
As a result, I haven't used R for serious work in the last couple of months, and last I checked, RStudio didn't support Julia (outside of using a binding like the [JuliaCall](https://github.com/Non-Contradiction/JuliaCall) R package from within R scripts, which is not ideal from a reproducibility standpoint and doesn't address needs 2. and 3. particularly well).
It's certainly not essential to use the same IDE for all languages, but it definitely makes it easier to switch between projects, and there are fewer configurations to maintain and get used to.

That rules out RStudio, but what about VSCode?
Well, I actually had switched to using VSCode entirely for my R code 2 years ago.
The main reason was not because I was starting to learn Julia (though it did coincide with this), but actually because ~~*RStudio couldn't handle*~~ I didn't search hard enough to figure out how to get RStudio to handle some of my larger projects.
Because I was working with larger and larger datasets, and often trying to make use of parallelization to speed up long-running code, I was running into memory issues with RStudio (at the time I was working on a 10 year old MacBook Pro that had seen it's fair share of hardships and was absolutely not up to the task).
Unfortunately, RStudio's biggest strength was also it's biggest weakness for me: by including everything within the IDE, there's no way to separate your console and R session from the editor.
If RStudio crashes, it takes your session down with it.
And in my case, it was crashing a lot, requiring me to restart long computations far more often than was actually required: the same scripts (technically [`{targets}`](https://books.ropensci.org/targets/) pipelines) would run fine in the terminal!^[If you use R and you haven't come across `{targets}` yet, do yourself a favor and go learn it now! Not only does it make your code more reproducible by removing the questions about which scripts need to be run when something is updated (this comes with the added benefit of not needing to re-run calculations when their dependencies haven't changed) but it also makes it easier to debug as it encourages smaller modular functions.]
It turns out there are ways to circumvent this issue using the technique described below, and it's [been around for a while](https://www.r-bloggers.com/2018/09/4-ways-to-be-more-productive-using-rstudios-terminal/), so this point was actually my biggest weakness, not RStudio's, but the end result was the same as I ended up mostly switching to Julia.

VSCode solved this issue for me because it has an integrated terminal (like RStudio), but it doesn't have a dedicated console, so all code is sent to the terminal that is currently open.
At first glance, this doesn't seem to be any different from RStudio's integrated console.
However, the difference is that I could use a terminal multiplexer like [tmux](https://github.com/tmux/tmux/wiki/Getting-Started) from within the VSCode terminal, allowing me to separate my R session from my editor.
If you're not familiar with terminal multiplexers like tmux, that's OK, I wasn't either at first.
Essentially, they allow you to create multiple persistent terminals that will stay open and running even if you close your terminal window.
They are useful when working on servers and you want to guard against accidentally losing connection because of internet issues etc., but as you can imagine, they come in handy for local development too.
In my case, I could open up a tmux session (in the VSCode terminal), start R, and then VSCode would send the commands to the R session running in tmux, and if VSCode crashed, I could just re-open it and reconnect to the tmux session, which would still be running.




## What does NeoVim do better?

## What are the pain points?

